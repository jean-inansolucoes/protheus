#include "rwmake.ch"
#include "topconn.ch"
#include "protheus.ch"
#include "FWMVCDef.ch"

/*


`ͻ
Programa  LTMOV011  Autor  Marcelo Joner         Data  16/04/2020 
͹
Desc.     Rotina utilizada para importao de movimentos de dbito na 
          conta corrente de produtores.                               
͹
Uso        Laticinio                                                  
ͼ


*/
User Function LTMOV011()

Local oProcess
Local cFuncao		:= "LTMOV011"
Local cPerg			:= "LTMOV011LT"
Local cTitle		:= " Importao - Conta Corrente Produtor "
Local bProcess		:= {|oSelf| MOV011IMP(oSelf)}
Local cDescricao	:= "  Esta rotina tem como objetivo efetuar  importao de movimentos de dbito"+ CRLF +;
					   "  junto  composio da conta corrente dos produtores. "

Private lLinux		:= "LINUX" $ UPPER(GetSrvInfo()[2])
Private cPathErro	:= "LTMOV011_ERRO"+ If(lLinux,"/","\")  // Pasta abaixo da Protheus_Data para gravar os LOGS de ERRO
Private cPathLOG	:= "LTMOV011_LOG" + If(lLinux,"/","\")  // Pasta abaixo da Protheus_Data para gravar os LOGS

//
//Executa regras de verificao e criao dos diretrios de log
//
If !EXISTDIR(cPathErro)
	nPath := MakeDir(cPathErro)
	If nPath != 0
		U_GLALL001("Ateno", "No foi possvel criar o diretrio " + cPathErro, "Favor incluir o diretrio " + cPathErro + " abaixo de PROTHEUS_DATA.")
		Return
	EndIf
EndIf

//
//Executa o objeto referente  execuo da rotina
//
oProcess := tNewProcess():New(cFuncao, cTitle, bProcess, cDescricao, cPerg, , , , , .T., .F.)

Return





/*


`ͻ
Programa  MOV011IMP  Autor  Marcelo Joner        Data  17/04/2020 
͹
Desc.     Funo responsvel pela execuo das regras de processamento
          da importao dos movimentos na conta corrente dos produtor.
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function MOV011IMP(oProcess)

Local lRet			:= .T.
Local lFlag			:= .T.
Local nX			:= 0
Local nHdl			:= 0
Local nLin			:= 0 
Local nBuffer		:= 0
Local nTotal		:= 0
Local nReadTot		:= 0
Local cCodMot		:= MV_PAR01
Local cArqCSV		:= ALLTRIM(MV_PAR02)
Local aStruct		:= {{"XX_FILIAL", "C", TAMSX3("ZLB_FILIAL")[1]	, TAMSX3("ZLB_FILIAL")[2]},;
						{"XX_DTMOV"	, "D", TAMSX3("ZLB_DTMOV")[1]	, TAMSX3("ZLB_DTMOV")[2] },;
						{"XX_CPFFOR", "C", TAMSX3("A2_CGC")[1]		, TAMSX3("A2_CGC")[2]	 },;
						{"XX_CODFOR", "C", TAMSX3("A2_COD")[1]		, TAMSX3("A2_COD")[2]	 },;
						{"XX_LOJFOR", "C", TAMSX3("A2_LOJA")[1]		, TAMSX3("A2_LOJA")[2]	 },;
						{"XX_NOMFOR", "C", TAMSX3("A2_NOME")[1]		, TAMSX3("A2_NOME")[2]	 },;
						{"XX_NUMNFE", "C", TAMSX3("ZLB_NF3")[1]		, TAMSX3("ZLB_NF3")[2]	 },;
						{"XX_VLRNFE", "N", TAMSX3("ZLB_VALOR")[1]	, TAMSX3("ZLB_VALOR")[2] },;
						{"XX_CODMOV", "C", TAMSX3("ZLB_COD")[1]		, TAMSX3("ZLB_COD")[2]	 },;
						{"XX_OBS"	, "C", 100						, 0						 },;
						{"XX_STATUS", "C", 1						, 0						 }}

Private cTabTMP
Private lMsErroAuto := .F. 
Private cAliasTMP	:= GetNextAlias()

Do Case
	//
	//Valida informao do cdigo do tipo de dbito de importao
	//
	Case EMPTY(cCodMot)
		U_GLALL001("Ateno", "No foi informado o cdigo do tipo de dbito para importao dos movimentos.", "Favor informar o cdigo do tipo de dbito para importao.")
	
	//
	//Valida informao do arquivo que contm os movimentos  serem importados
	//
	Case EMPTY(cArqCSV)
		U_GLALL001("Ateno", "No foi informado o arquivo que contm as informaes  serem importadas.", "Favor informar o arquivo de importao dos movimentos.")
	
	//
	//Caso o arquivo informado no seja CSV, no executa  rotina
	//
	Case !".CSV" $ UPPER(cArqCSV)
		U_GLALL001("Ateno", "O arquivo informado no  do tipo CSV.", "Somente  possvel utilizar  rotina, caso o arquivo utilizado seja do tipo CSV.")
	
	//
	//Executa regras de processamento da rotina
	//
	OtherWise
		
		//
		//Cria tabela temporria para gerao de log que ser apresentado em relatrio ao trmino da execuo
		//
		cTabTMP := CriaTrab(aStruct, .T.)
		dbUseArea(.T.,, cTabTMP ,cAliasTMP, .F., .F.)
		dbSelectArea(cAliasTMP)
		
		//
		//Valida se o tipo de dbito informado  vlido
		//
		dbSelectArea("SX5")
		SX5->(dbSetOrder(1))
		SX5->(dbGoTop())
		If !SX5->(dbSeek(xFilial("SX5") + "LT" + PADR(cCodMot, 2)))
			U_GLALL001("Ateno", "O tipo de dbito informado para os movimentos  invlido.", "Favor verificar o tipo de dbito informado para importao dos movimentos.")
			lRet := .F.
		EndIf
		
		//
		//Valida se o arquivo informado  vlido
		//
		If lRet
			nHdl := fOpen(cArqCSV,0)
			If nHdl == -1
			    U_GLALL001("Ateno", "No foi possvel abrir o arquivo " + cArqCSV + ".", "Favor verificar o arquivo informado para importao dos movimentos.")
				lRet := .F.
			Else
				//
				//Obtm o tamanho total do arquivo
				//
				nTotal := FSeek(nHdl, 0, 2)
				
				//
				//Aloca no maximo 500kb
				//
				nBuffer := Min(500*1024, nTotal)
				
				//
				//Posiciona no inicio do arquivo
				//
				FSeek(nHdl, 0, 0)
			EndIf
		EndIf
				
		//
		//Aps  validao dos parmetros, executa demais regras de importao
		//
		If lRet
			
			//
			//Realiza leitura total do arquivo
			//
			While nReadTot < nTotal
				cBuffer  := SPACE(nBuffer)
				nRead    := FRead(nHdl, @cBuffer, nBuffer)
				nReadTot += nRead
				If (nRead <> nBuffer .AND. nReadTot <> nTotal)
					MsgStop("Erro na leitura do arquivo !","Aviso")
					Break
				EndIf
			End
			
			//
			//Seta reguas de processamento da rotina
			//
			oProcess:SetRegua1(4) 
			oProcess:SetRegua2(2)
			oProcess:IncRegua1("Abrindo arquivo...")
			oProcess:IncRegua2("Importao - Conta Corrente Produtor")
			
			oProcess:SaveLog("Abrindo arquivo...")
			
			//
			//Recupera os dados do buffer
			//
			If Len(cBuffer) > 0
				nPOSATUAL := 1
				cSRT := CHR(10)
				fGetTXT(cBuffer, @nPOSATUAL, cSRT)
				
				//
				//Retira primeira linha do cabealho do buffer
				//
				cBuffer := SubSTR(cBuffer, nPOSATUAL, Len(cBuffer))
				cBufSUB := ""
				          
				nRegistro := 0
				nITEM := 1
				
				//
				//Incremente barra de processamento
				//
				oProcess:IncRegua1("Lendo informaes do arquivo...")
				oProcess:SaveLog("Lendo informaes do arquivo...")
				
				//
				//Executa lao para leitura de todas as linhas do arquivo
				//
				While lFlag
					cSRT := CHR(10)
					nPOSATUAL := 1
					nLin += 1
					fGetTXT(cBuffer, @nPOSATUAL, cSRT)
					cBufSUB := ""
					cBufSUB := SUBSTR(cBuffer, 1, nPOSATUAL-2)
					cBuffer := SUBSTR(cBuffer, nPOSATUAL, Len(cBuffer))
					nPOSATUAL2 := 1
					
					//
					//Havendo carregado informaes, realiza sequncia  execuo
					//
					If !EMPTY(cBufSUB)
					
						//
						//A partir da string obtida, compe array separando os itens pela ,
						//
						cBufSUB := STRTRAN(cBufSUB, CHR(10), "")
						aDetBUF := STRTOKARR2(cBufSUB, ";", .T.)
						
						//
						//Remove " dos itens do array criado
						//
						For nX := 1 To Len(aDetBUF)
							aDetBUF[nX] := STRTRAN(aDetBUF[nX], '"', '')
						Next nX
						
						//
						//Considera apenas as linhas com 6 itens
						//
						If Len(aDetBUF) == 6
							
							//
							//Prepara variaveis com os dados da linha atual do arquivo
							//
							cDatLan := CTOD(aDetBUF[1])
							cNomFor := aDetBUF[2]
							cNomFan	:= aDetBUF[3]
							cCpfFor	:= PADR(STRTRAN(aDetBUF[4], '-', ''), TAMSX3("A2_CGC")[1])
							cNfeVen	:= STRZERO(VAL(STRTRAN(aDetBUF[5], ".", "")), 9)
							nVlrVen := VAL(STRTRAN(aDetBUF[6], ",", "."))
							
							//
							//Adiciona informaes ao array de movimentos  serem importados
							//
							RECLOCK(cAliasTMP, .T.)
								(cAliasTMP)->XX_FILIAL := xFilial("ZLB")
								(cAliasTMP)->XX_DTMOV  := cDatLan
								(cAliasTMP)->XX_CPFFOR := cCpfFor
								(cAliasTMP)->XX_CODFOR := cNomFan
								(cAliasTMP)->XX_NOMFOR := cNomFor
								(cAliasTMP)->XX_NUMNFE := cNfeVen
								(cAliasTMP)->XX_VLRNFE := nVlrVen
							(cAliasTMP)->(MSUNLOCK())
						EndIf
					Else
						exit
					EndIf
				End
				
				//
				//Fecha o arquivo utilizado para leitura das informaes
				//
				fClose(nHdl)
				
				//
				//Obtm o nmero de registros da tabela temporria
				//
				nTotReg := (cAliasTMP)->(RECCOUNT())
				
				//
				//Caso existam registros na tabela temporria, executa demais regras de importao
				//
				If nTotReg > 0
					nRegImp := 1
					
					//
					//Atualiza o log de execuo da rotina
					//
					oProcess:SaveLog("Importando movimentos para conta corrente...")
					
					//
					//Executa lao para incluso na Conta Corrente
					//
					(cAliasTMP)->(dbGoTop())
					While (cAliasTMP)->(!EOF())
						
						//
						//Incremente barra de processamento
						//
						nRegImp++
						oProcess:IncRegua1("Importando movimento " + ALLTRIM(STR(nRegImp)) + " de " + ALLTRIM(STR(nTotReg)) + "...")
						
						//
						//Posiciona no cadastro do Fornecedor vinculado ao item do arquivo CSV posicionado
						//
						dbSelectArea("SA2")
						SA2->(dbSetOrder(3))
						SA2->(dbGoTop())
						If SA2->(dbSeek(xFilial("SA2") + (cAliasTMP)->XX_CPFFOR))
							lValido := .F.
							nSA2Rec := SA2->(RECNO())
							While SA2->(!EOF()) .AND. SA2->A2_FILIAL == xFilial("SA2") .AND. SA2->A2_CGC == (cAliasTMP)->XX_CPFFOR
								If SA2->A2_MSBLQL != "1"
									lValido := .T.
									exit
								EndIf
								
								SA2->(dbSkip())
							End
							
							//
							//Executa demais regras, caso tenha encontrado cadastro do fornecedor que seja vlido
							//
							If lValido
								
								//
								//Verifica se j existe registro deste movimento para o produtor
								//
								dbSelectArea("ZLB")
								ZLB->(dbSetOrder(5))
								ZLB->(dbGoTop())
								If !ZLB->(dbSeek(xFilial("ZLB") + SA2->A2_COD + SA2->A2_LOJA + DTOS((cAliasTMP)->XX_DTMOV) + (cAliasTMP)->XX_NUMNFE))
									cDetHist := "REF. NF " + ALLTRIM((cAliasTMP)->XX_NUMNFE)
									
									//
									//Prepara array para incluso do Mov. Conta Corrente
									//
									aMOV004 := {}
									AADD(aMOV004, {'ZLB_FILIAL'	, xFilial("ZLB")		, Nil})
									AADD(aMOV004, {'ZLB_FORNEC'	, SA2->A2_COD			, Nil})
									AADD(aMOV004, {'ZLB_LOJFOR'	, SA2->A2_LOJA			, Nil})
									AADD(aMOV004, {'ZLB_NOMFOR'	, SA2->A2_NOME			, Nil})
									AADD(aMOV004, {'ZLB_TIPCD'	, "D"					, Nil})
									AADD(aMOV004, {'ZLB_TPDESP'	, cCodMot				, Nil})
									AADD(aMOV004, {'ZLB_VALOR'	, (cAliasTMP)->XX_VLRNFE, Nil})
									AADD(aMOV004, {'ZLB_DTMOV'	, (cAliasTMP)->XX_DTMOV	, Nil})
									AADD(aMOV004, {'ZLB_NF3'	, (cAliasTMP)->XX_NUMNFE, Nil})
									AADD(aMOV004, {'ZLB_HIST'	, cDetHist				, Nil})
									AADD(aMOV004, {'ZLB_DESDOB'	, "N"					, Nil})
									
									//
									//Executa rotina de incluso do movimento na Conta Corrente do produtor
									//
									MSExecAuto({|x,y| U_LTMOV004(x,y)}, aMOV004, 3)
									
									//
									//Verifica se ocorreu erro na incluso do Mov. Conta Corrente
									//
									If lMsErroAuto
										lMsErroAuto := .F.
										RECLOCK(cAliasTMP, .F.)
											(cAliasTMP)->XX_OBS    := ALLTRIM(SUBSTR(MOSTRAERRO("\" + cPathErro, "ltmov004_erro.txt"), 1, 80))
											//(cAliasTMP)->XX_CODFOR := SA2->A2_COD
											//(cAliasTMP)->XX_LOJFOR := SA2->A2_LOJA
											(cAliasTMP)->XX_STATUS := "2"
										(cAliasTMP)->(MSUNLOCK())
									Else
										//
										//Aps incluso com sucesso, adiciona informaes na tabela temporria
										//
										RECLOCK(cAliasTMP, .F.)
											(cAliasTMP)->XX_OBS    := "MOVIMENTO REALIZADO"
											//(cAliasTMP)->XX_CODMOV := ZLB->ZLB_COD
											//(cAliasTMP)->XX_CODFOR := SA2->A2_COD
											//(cAliasTMP)->XX_LOJFOR := SA2->A2_LOJA
											//(cAliasTMP)->XX_STATUS := "1"
										(cAliasTMP)->(MSUNLOCK())
									EndIf
								Else
									//
									//Caso localizou o movimento j existente, registra log de observao
									//
									RECLOCK(cAliasTMP, .F.)
										(cAliasTMP)->XX_OBS    := "MOVIMENTO IMPORTADO ANTERIORMENTE"
										//(cAliasTMP)->XX_CODMOV := ZLB->ZLB_COD
										//(cAliasTMP)->XX_CODFOR := SA2->A2_COD
										//(cAliasTMP)->XX_LOJFOR := SA2->A2_LOJA
										(cAliasTMP)->XX_STATUS := "2"
									(cAliasTMP)->(MSUNLOCK())
								EndIf
							Else
								//
								//No existe cadastro vlido para o fornecedor vinculado ao movimento
								//
								RECLOCK(cAliasTMP, .F.)
									(cAliasTMP)->XX_OBS    := "NO EXISTE CADASTRO DE FORNECEDOR VLIDO"
									(cAliasTMP)->XX_CODMOV := ""
									(cAliasTMP)->XX_CODFOR := ""
									(cAliasTMP)->XX_LOJFOR := ""
									(cAliasTMP)->XX_STATUS := "2"
								(cAliasTMP)->(MSUNLOCK())
							EndIf
						Else
							//
							//Caso no localizou o fornecedor, registra log de observao
							//
							RECLOCK(cAliasTMP, .F.)
								(cAliasTMP)->XX_OBS    := "FORNECEDOR NO LOCALIZADO"
								(cAliasTMP)->XX_CODFOR := ""
								(cAliasTMP)->XX_LOJFOR := ""
								(cAliasTMP)->XX_STATUS := "2"
							(cAliasTMP)->(MSUNLOCK())
						EndIf
						
						//
						//Posiciona no prximo registro para importao
						//
						(cAliasTMP)->(dbSkip())
					End
					
					//
					//Executa funo para gerao de relatrio de log de execuo
					//
					oProcess:IncRegua1("Gerando relatrio de logs....")
					oProcess:IncRegua2("Finalizando - Conta Corrente Produtor")
					oProcess:SaveLog("Gerando relatrio com os logs de execuo...")
					MOV011REL()
				Else
					//
					//Alerta o usurio, pois no foram localizadas informaes para importao
					//
					U_GLALL001("Ateno", "No foi possvel obter informaes para importao no arquivo informado.", "Verifique o arquivo utilizado para importao.")
				EndIf
			EndIf
		EndIf
EndCase

Return





/*


`ͻ
Programa  FGETTXT   Autor  Marcelo Joner         Data  17/04/2020 
͹
Desc.     Funo responsvel pela leitura do arquivo de movimentos pa-
          ra importao na Conta Corrente dos produtores.             
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function FGETTXT(cTXT, nPOSATUAL, cSRT)

Local cRET := ""
Local nI := 0

If nPOSATUAL < Len(cTXT)
	For nI := nPOSATUAL to Len(cTXT)
		If ! SubSTR(cTXT,nI,1) $ cSRT
			cRET += SubSTR(cTXT,nI,1)
		Else                  
			If cSRT == CHR(13)+CHR(10)
				nPOSATUAL := nI+2
			Else                 
				nPOSATUAL := nI+1
			EndIf
			Exit
		EndIf
	Next nI
EndIf

Return cRET





/*


ͻ
Programa  MOV011REL   Autor Marcelo Joner        Data  17/04/2020 
͹
Descricao Funo de execuo de relatrio de log ao trmino da execu- 
          o da importao de movimentos de conta corrente.          
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function MOV011REL()

Private oReport
Private cFile		:= "LTMOV11REL"
Private cTitle		:= "Log - Importao Conta Corrente"
Private cHelp		:= "Relatrio responsvel por apresentar as principais informaes  respeito do log de execuo da importao de movimentos na conta corrente dos produtores."

//
//Cria o objeto pertinente ao processamento do relatrio
//
oReport := REL011()
oReport:PRINTDIALOG()

Return





/*


`ͻ
Programa  REL011  Autor  Marcelo Joner         Data   17/04/2020  
͹
Desc.     Funo responsvel pelo processamento das demais regras em  
          torno da execuo do relatrio.                             
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function REL011()

//
//Cria o componente de processamento do relatrio
//
oReport := TReport():New(cFile, cTitle,, {|oReport| REL011PRT(oReport)}, cHelp,, "")
oReport:SetLandscape()
oReport:EndReport(.F.)
oReport:SetTotalInLine(.F.)
oReport:bTotalPrint := {|| }

//
//Cria a sesso principal de FILIAIS
//
oSection1 := TRSection():New(oReport, "FILIAL", {"SM0"}, {})
oSection1:cAlias := cAliasTMP
TRCell():New(oSection1, "XX_FILIAL"	, ""   , "Filial")
TRCell():New(oSection1, "M0_FILIAL"	, "SM0", "Descrio", "@!", 50,, {|| POSICIONE("SM0", 1, cEmpAnt + (cAliasTMP)->XX_FILIAL, "M0_FILIAL")})

//
//Cria a sesso principal de MOVIMENTOS PROCESSADOS
//
oSection2 := TRSection():New(oSection1, "Movimentos Processados", {})
oSection2:SetLeftMargin(02)
oSection2:cAlias := cAliasTMP
oSection2:lHeaderVisible := .T.
TRCell():New(oSection2, "XX_DTMOV"	, "", "Data Mov.",,10)
//TRCell():New(oSection2, "XX_CODMOV"	, "", "Cdigo Mov.",,TAMSX3("ZLB_COD")[1])
TRCell():New(oSection2, "XX_CPFFOR"	, "", "Cpf\Cnpj",,TAMSX3("A2_CGC")[1])
TRCell():New(oSection2, "XX_CODFOR"	, "", "Fornecedor",,TAMSX3("A2_COD")[1])
TRCell():New(oSection2, "XX_LOJFOR"	, "", "Loja",,TAMSX3("A2_LOJA")[1])
TRCell():New(oSection2, "XX_NOMFOR"	, "", "Nome",,TAMSX3("A2_NOME")[1])
TRCell():New(oSection2, "XX_NUMNFE"	, "", "Nota Fiscal",,TAMSX3("ZLB_NF3")[1])
TRCell():New(oSection2, "XX_VLRNFE"	, "", "Valor",PESQPICT("ZLB", "ZLB_VALOR"),TAMSX3("ZLB_VALOR")[1])
TRCell():New(oSection2, "XX_OBS"	, "", "Observaes",,100)

Return oReport





/*


`ͻ
Programa  REL011PRT   Autor  Marcelo Joner       Data  17/04/2020 
͹
Desc.     Funo responsvel pela execuo das regras em torno da exe-
          cuo do relatrio de log de processamento.                 
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function REL011PRT(oReport)

Local oSection1	:= oReport:Section(1)

//
//Cria indice e posiciona no primeiro registro da tabela temporria
//
dbSelectArea(cAliasTMP)
IndRegua(cAliasTMP, cTabTMP, "XX_STATUS+DTOS(XX_DTMOV)+XX_CODFOR+XX_LOJFOR",,, "Selecionando Registros...")
(cAliasTMP)->(dbSetOrder(1))
(cAliasTMP)->(dbGoTop())

//
//Seta regra de contador do processamento
//
oReport:SetMeter((cAliasTMP)->(RECCOUNT()))

//
//Executa a impresso das sesses do relatrio
//
oSection1:Print()

Return
