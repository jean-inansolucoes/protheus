#include "rwmake.ch"
#include "topconn.ch"
#include "protheus.ch"

/*


`ͻ
Programa  LT019TRP  Autor  Marcelo Joner         Data  27/04/2020 
͹
Desc.     Funo referente h execuo das regras em torno da funciona
          lidade Conciliar browse da rotina de Pesagem.       		  
͹
Uso        Laticinio                                                  
ͼ


*/
User Function LT019TRP(cAlias, nReg, nOpc, lExeCon)

//Local aArea			:= GetArea()
	Local aSize			:= {}
	Local aObjects		:= {}
	Local aInfo			:= {}
	Local aBotoes		:= {}
	Local aCpoCab		:= {}
	Local aAltCab		:= {}
	Local aCpoCon		:= {}
	Local aAltCon		:= {}
	Local aCpoTot		:= {}
	Local aAltTot		:= {}
	Local aVwTRP		:= {}
	Local lF3			:= .F.
	Local lColumn		:= .F.
	Local lMemoria		:= .T.
	Local lNoFolder		:= .T.
	Local lProperty		:= .F.
	Local lInverte		:= .F.
	Local lShare		:= .T.
	Local lReadOnly		:= .F.
//Local nI			:= 0
	Local nX			:= 0
	Local nOpcao		:= 2
	Local cMarca		:= GetMark()
//Local cCadOld		:= cCadastro

	Private oBrwTrp
	Private oGetCon
	Private aGets[0]
	Private aGets1[0]
	Private aGets2[0]
	Private aGets3[0]
	Private aTela[0][0]
	Private aTela1[0][0]
	Private aTela2[0][0]
	Private aTela3[0][0]

	Private lTemNf		:= !EMPTY(ZM1->ZM1_NFCOM)
	Private cAliasTRP	:= GetNextAlias()

	Private bCampo		:= {|nCPO| Field(nCPO)}

	Private VISUAL		:= .F.
	Private INCLUI		:= .F.
	Private ALTERA		:= .T.
	Private DELETA		:= .F.

	Default cAlias		:= "ZM1"
	Default nReg		:= 0
	Default nOpc		:= 2
	Default lExeCon		:= .F.

//
//Posiciona no cadastro do produto vinculado h pesagem
//
	dbSelectArea("SB1")
	SB1->(dbSetOrder(1))
	SB1->(dbGoTop())
	If SB1->(dbSeek(xFilial("SB1") + ZM1->ZM1_PROD))

		//
		//Havendo Tipo Anlise vinculada ao produto da pesagem, valida se h foram informados as anlises de qualidade
		//
		lDetQld := .T.
		If !EMPTY(SB1->B1_X_TPANA)
			lDetQld := ZM1->ZM1_SITQLD == "F"
		EndIf

		//
		//Executa sequncia, caso as regras de anlise de qualidade para o produto\pesagem estejam de acordo
		//
		If lDetQld

			//
			//Executa demais regras, caso exista regra de obteno do fator de converso definida no cadastro do produto
			//
			If !EMPTY(SB1->B1_X_FCONV)

				//
				//Executa  frmula para obter o fator de converso
				//
				nFator := FORMULA(SB1->B1_X_FCONV)

				//
				//Caso seja obtido fator numrico maior que zero, executa demais regras
				//
				If Type("nFator") == "N" .AND. nFator > 0

					//
					//Altera o ttulo apresentado na interface ao usurio
					//
					cCadastro := "Pesagens - Conciliar"

					//
					//Monta arrays com estruturas para MsMGet
					//
					aCpoCab := {"NOUSER", "ZM1_COD", "ZM1_TIPO", "ZM1_DATA", "ZM1_PROD", "ZM1_DESC", "ZM1_TRANSP", "ZM1_DTRANS", "ZM1_CODVEI", "ZM1_PLACA", "ZM1_CODMOT", "ZM1_NOMMOT", "ZM1_CODLIN", "ZM1_NOMLIN"}
					aAltCab := {}
					aCpoTot := {"NOUSER", "ZM1_KGINI", "ZM1_DTINI", "ZM1_HRINI", "ZM1_KGFIN", "ZM1_DTFIN", "ZM1_HRFIN", "ZM1_KGBRT"}
					aAltTot := {}

					//
					//Havendo nota fiscal vinculada h pesagem, no considera vinculo de MOV. TRANSPORTADOR
					//
					If lTemNf
						aCpoCon := {"NOUSER", "ZM1_LTBRT", "ZM1_TPNOTA", "ZM1_LTNOTA", "ZM1_LTDIF", "ZM1_QLD022", "ZM1_SLKG", "ZM1_SLLT", "ZM1_SITCON", "ZM1_PRCSOL", "ZM1_FATCON"}
						aAltCon := IIF(lExeCon, {"ZM1_TPNOTA","ZM1_LTNOTA", "ZM1_SITCON","ZM1_PRCSOL"}, {})
					ELse
						//
						//Demais casos, considera vinculo de MOV. TRANSPORTADOR
						//
						aCpoCon := {"NOUSER", "ZM1_LTBRT", "ZM1_LTMOV", "ZM1_LTDIF", "ZM1_LTDESC", "ZM1_DESTRP", "ZM1_LTVAZ", "ZM1_SITCON"}
						aAltCon := IIF(lExeCon, {"ZM1_DESTRP", "ZM1_SITCON"}, {})
					EndIf

					//
					//Composio de arrays com estrutura dos campos para visualizao
					//
					AADD(aVwTRP, {"ZL7_COD"   	, "", "Cdigo"		 , U_LTALLXSX3("ZL7_COD")[6]   	})
					AADD(aVwTRP, {"ZL7_DATA"	, "", "Data"		 , U_LTALLXSX3("ZL7_DATA")[6]	})
					AADD(aVwTRP, {"ZL7_HORA"	, "", "Hora"		 , U_LTALLXSX3("ZL7_HORA")[6]	})
					AADD(aVwTRP, {"ZL7_PLACA"	, "", "Placa"		 , U_LTALLXSX3("ZL7_PLACA")[6]	})
					AADD(aVwTRP, {"ZL7_LINHA"   , "", "Linha"		 , U_LTALLXSX3("ZL7_LINHA")[6]  })
					AADD(aVwTRP, {"ZL7_NOMLIN"  , "", "Descrio"	 , U_LTALLXSX3("ZL7_NOMLIN")[6] })
					AADD(aVwTRP, {"ZL7_QTDTRP"  , "", "Qtd. Transp." , U_LTALLXSX3("ZL7_QTDTRP")[6] })
					AADD(aVwTRP, {"ZL7_QTDVAZ"  , "", "Qtd. Vazo"	 , U_LTALLXSX3("ZL7_QTDVAZ")[6] })
					AADD(aVwTRP, {"ZL7_QTDSOB"  , "", "Qtd. Sobra"	 , U_LTALLXSX3("ZL7_QTDSOB")[6] })
					AADD(aVwTRP, {"ZL7_QTDFAL"  , "", "Qtd. Falta"	 , U_LTALLXSX3("ZL7_QTDFAL")[6] })
					AADD(aVwTRP, {"ZL7_QTDANT"  , "", "Qtd. Desconto", U_LTALLXSX3("ZL7_QTDANT")[6] })
					AADD(aVwTRP, {"ZL7_QTDDES"  , "", "Qtd. Descarte", U_LTALLXSX3("ZL7_QTDDES")[6] })

					aStruTRP := ZL7->(dbStruct())

					//
					//Executa consulta SQL de busca dos MOV. TRANSPORTADOR vinculados  pesagem
					//
					cQuery := "SELECT ZL7.*											" + CRLF
					cQuery += "FROM " + RetSQLName("ZL7") + " ZL7					" + CRLF
					cQuery += "WHERE ZL7.ZL7_FILIAL  = '" + xFilial("ZL7") + "'		" + CRLF
					cQuery += "  AND ZL7.ZL7_NUMPES  = '" + ZM1->ZM1_NUM   + "'		" + CRLF
					cQuery += "  AND ZL7.D_E_L_E_T_ <> '*'							" + CRLF

					cQuery += "ORDER BY ZL7_FILIAL, ZL7_DATA, ZL7_HORA, ZL7_COD		" + CRLF

					cArqTrab  := CriaTrab(aStruTRP, .T. )

					If Select(cAliasTRP) > 0
						(cAliasTRP)->(dbCloseArea())
					EndIf

					cQuery := ChangeQuery(cQuery)

					TCQUERY cQuery NEW ALIAS cAliasTRP

					Copy TO &cArqTrab
					dBCloseArea()
					dBUseArea(.T.,, cArqTrab, cAliasTRP, lShare, lReadOnly)
					(cAliasTRP)->(dbGoTop())

					//
					//Atribui aos campos em memria, os valores do registro da tabela posicionado
					//
					dbSelectArea(cAlias)
					For nX := 1 TO FCount()
						M->&(Eval(bCampo, nX)) := FieldGet(nX)
					Next nX

					//
					//Executa regras para composio do KG Descarte
					//
					nLtPlataforma := 0
					dbSelectArea("ZM3")
					ZM3->(dbSetOrder(1))
					ZM3->(dbGoTop())
					If ZM3->(dbSeek(xFilial("ZM3") + M->ZM1_NUM))
						While ZM3->(!EOF()) .AND. ZM3->ZM3_FILIAL == xFilial("ZM3") .AND. ZM3->ZM3_NUM == M->ZM1_NUM
							nLtPlataforma += (ZM3->ZM3_KGANT - ZM3->ZM3_KGPOS)
							ZM3->(dbSkip())
						End
					EndIf


					//
					//Executa regras de clculo do fator de converso
					//
					If nLtPlataforma == 0
						M->ZM1_FATCON := IIF(M->ZM1_FATCON == 0, nFator, M->ZM1_FATCON)
						M->ZM1_LTBRT  := IIF(M->ZM1_LTBRT  == 0, ROUND((M->ZM1_KGBRT  * M->ZM1_FATCON), 0), M->ZM1_LTBRT)
						M->ZM1_LTDESC := IIF(M->ZM1_LTDESC == 0, ROUND(((ZM1->ZM1_KGIDES-ZM1->ZM1_KGFDES) * M->ZM1_FATCON), 0), M->ZM1_LTDESC)
					Else
						M->ZM1_FATCON := IIF(M->ZM1_FATCON == 0, nFator, M->ZM1_FATCON)
						M->ZM1_LTBRT  := IIF(M->ZM1_LTBRT  == 0, ROUND((nLtPlataforma * M->ZM1_FATCON), 0), M->ZM1_LTBRT)
						M->ZM1_LTDESC := IIF(M->ZM1_LTDESC == 0, ROUND((ZM1_KGBRT * M->ZM1_FATCON), 0), M->ZM1_LTDESC)
					EndIf

					//
					//Executa funo de clculo dos solidos
					//
					If lTemNf
						aDetSL := LT019CLCSL()
						M->ZM1_QLD022 := IIF(M->ZM1_QLD022 == 0, aDetSL[1], M->ZM1_QLD022)
						M->ZM1_SLKG   := IIF(M->ZM1_SLKG   == 0, aDetSL[2], M->ZM1_SLKG)
						M->ZM1_SLLT   := IIF(M->ZM1_SLLT   == 0, aDetSL[3], M->ZM1_SLLT)
						M->ZM1_LTDIF  := IIF(M->ZM1_LTDIF  == 0, ROUND(((M->ZM1_LTBRT + M->ZM1_LTDESC) - M->ZM1_LTNOTA), 0) , M->ZM1_LTDIF)
						M->ZM1_PRCSOL := IIF(M->ZM1_PRCSOL == 0 .AND. ZM1->ZM1_SITCON !='F', U_LTPRCSOL(),M->ZM1_PRCSOL)
					Else
						M->ZM1_LTDIF  := IIF(M->ZM1_LTDIF  == 0, ROUND(((M->ZM1_LTBRT + M->ZM1_LTDESC) - M->ZM1_LTMOV), 0) , M->ZM1_LTDIF)
					EndIf

					//
					//Caso encontre dados de conciliao pergunta se quer preprocessar
					//
					If ZM1->ZM1_FATCON != 0 .and. ZM1->ZM1_SITCON == 'P' .AND. lExeCon .and. lTemNf
						
							LT019RECC(lTemNf, aDetSL)
						
					EndIf

					//
					//Havendo ocorrncia de Conciliao, disponibiliza opo para visualizao do log
					//
					If !EMPTY(ZM1->ZM1_USRCON)
						AADD(aBotoes, {"UPDWARNING", {|| LT019LOG()}, "Log"})
					EndIf
					//
					//Havendo ocorrncia de Conciliao, disponibiliza opo para visualizao do log
					//
					If !EMPTY(ZM1->ZM1_USRCON)

						AADD(aBotoes, {"UPDMOVIMEN", {|| LT019RECC(lTemNf, aDetSL)}, "Recalcula"})
					EndIf
					//
					//estorno do preo do Slido para quepossibilite alterao da ZME				
					//
					If __cUserId $ SuperGetMV("MX_PRECCON",,"")
						AADD(aBotoes, {"UPDPRECO", {|| LT019ZERPR(lTemNf, aDetSL)}, "Zera Preo"})
					EndIf
					//
					//Calcula tamanho\posicionamento da interface
					//
					aSize := MsAdvSize()
					AADD(aObjects, {100, 030, .T., .T.})
					AADD(aObjects, {100, 070, .T., .T.})
					aInfo := {aSize[1], aSize[2], aSize[3], aSize[4], 2, 2}
					aPosObj := MsObjSize(aInfo, aObjects, .T.)

					//
					//Definio do Dialog e demais componentes da interface
					//
					DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
					oDlg:bInit := {|| ENCHOICEBAR(oDlg,{|| IIF(LT019TOK(), (oDlg:End(), nOpcao := 1), )}, {|| (oDlg:End(), nOpcao := 2)},.F.,aBotoes), LT019INI(lExeCon)}

					//
					//Componentes referentes ao CABEALHO
					//
					oGetCab := MSMGET():NEW(cAlias,nReg,nOpc, /*aCRA*/,/*cLetra*/,/*cTexto*/, aCpoCab, {aPosObj[1,1], aPosObj[1,2], aPosObj[1,3], aPosObj[1,4]}, aAltCab, 2,/*nColMens*/,/*cMensagem*/,'',oDlg, lF3, lMemoria, lColumn,/*caTela*/,lNoFolder,lProperty, /*aField*/, /*aFolder*/, .F., /*lNoMDIStretch*/,/*cTela*/)
					aGets1 := AClone(aGets)
					aTela1 := AClone(aTela)
					aGets  := {}
					aTela  := {}


					//
					//Componentes da sesso de COLETAS
					//
					oGrpTrp := TGroup():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4]-148,"Mov. Transportador",oDlg,CLR_HBLUE,CLR_WHITE,.T.,.F.)
					oBrwTrp := MsSelect():New(cAliasTRP,"","", aVwTRP,@lInverte,@cMarca,{aPosObj[2,1]+009,aPosObj[2,2]+003,aPosObj[2,3]-020,aPosObj[2,4]-152},,,oDlg)
					oBrwTrp:oBrowse:lHasMark     := .F.
					oBrwTrp:oBrowse:lCanAllMark  := .F.
					oBrwTrp:oBrowse:bLdBlClick := {|| IIF(!EMPTY((cAliasTRP)->ZL7_COD), LT019TRPAJ(), )}
					oBrwTrp:oBrowse:lActive := !lTemNf .AND. lExeCon

					//
					//Cria opes do boto de DETALHES da interface
					//
					oMnImp := TMenu():New(0,0,0,0,.T.)
					oTMnPrd := TMenuItem():New(oDlg, "Mov. &Produtor",,,,{|| LT019DET("P")},,,,,,,,,.T.)
					oMnImp:Add(oTMnPrd)
					oTMnTrp := TMenuItem():New(oDlg, "Mov. &Transportador",,,,{|| LT019DET("T")},,,,,,,,,.T.)
					oMnImp:Add(oTMnTrp)

					oButAdd := TButton():New(aPosObj[2,3]-017, aPosObj[2,2]+003, "&Adicionar", oDlg, {|| LT019ADD()}, 50,12,,,.F.,.T.,.F.,,.F.,,,.F. )
					oButAdd:lActive := !lTemNf .AND. lExeCon

					oButDet := TButton():New(aPosObj[2,3]-017, aPosObj[2,2]+063, "&Detalhes", oDlg, {|| }, 50,12,,,.F.,.T.,.F.,,.F.,,,.F. )
					oButDet:SetPopupMenu(oMnImp)
					oButDet:lActive := !lTemNf .AND. lExeCon

					oButRem := TButton():New(aPosObj[2,3]-017, aPosObj[2,2]+123, "&Remover", oDlg, {|| LT019DEL()}, 50,12,,,.F.,.T.,.F.,,.F.,,,.F. )
					oButRem:lActive := !lTemNf .AND. lExeCon

					//
					//Componentes da sesso de PESAGEM
					//
					oGrpTot := TGroup():New(aPosObj[2,1],aPosObj[2,4]-142,aPosObj[2,3]-132,aPosObj[2,4],"Pesagem",oDlg,CLR_HBLUE,CLR_WHITE,.T.,.F.)

					oGetTot := MSMGET():NEW(cAlias,nReg,nOpc, /*aCRA*/,/*cLetra*/,/*cTexto*/, aCpoTot, {aPosObj[2,1]+009,aPosObj[2,4]-138,aPosObj[2,3]-135,aPosObj[2,4]-003}, aAltTot, 2,/*nColMens*/,/*cMensagem*/,'',oDlg, lF3, lMemoria, .T.,/*caTela*/,lNoFolder,lProperty, /*aField*/, /*aFolder*/, .F., /*lNoMDIStretch*/,/*cTela*/)
					aGets2 := AClone(aGets)
					aTela2 := AClone(aTela)
					aGets  := {}
					aTela  := {}


					//
					//Componentes da sesso de CONCILIAO
					//
					oGrpCon := TGroup():New(aPosObj[2,3]-130,aPosObj[2,4]-142,aPosObj[2,3],aPosObj[2,4],"Conciliao",oDlg,CLR_HBLUE,CLR_WHITE,.T.,.F.)
					oGetCon := MSMGET():NEW(cAlias,nReg,nOpc, /*aCRA*/,/*cLetra*/,/*cTexto*/, aCpoCon, {aPosObj[2,3]-119,aPosObj[2,4]-138,aPosObj[2,3]-003,aPosObj[2,4]-003}, aAltCon, 2,/*nColMens*/,/*cMensagem*/,'',oDlg, lF3, lMemoria, .T.,/*caTela*/,lNoFolder,lProperty, /*aField*/, /*aFolder*/, .F., /*lNoMDIStretch*/,/*cTela*/)
					aGets3 := AClone(aGets)
					aTela3 := AClone(aTela)
					aGets  := {}
					aTela  := {}

					SetFocus(oBrwTrp:oBrowse:hWnd)

					ACTIVATE MSDIALOG oDlg

					//
					//Confirmando  tela, grava movimentos no banco
					//
					If lExeCon .AND. nOpcao == 1
						LT019GRV()
					EndIf

					//
					//Finaliza o alias temporrio utilizado pela funo
					//
					If Select(cAliasTRP) > 0
						(cAliasTRP)->(dbCloseArea())
					EndIf
				Else
					//
					//Alerta o usurio pois o fator de converso obtido  invlido
					//
					U_LTALL001("Ateno", "O fator de converso obtido para  pesagem  invlido.", "Favor verificar as definies do fator de converso no cadastro do produto vinculado  est pesagem.")
				EndIf
			Else
				//
				//Alerta o usurio pois no h regra de fator de converso para o produto da pesagem
				//
				U_LTALL001("Ateno", "No existe regra de composio do fator de converso para o produto desta pesagem.", "Favor verificar as definies do cadastro do produto vinculado  est pesagem.")
			EndIf
		Else
			//
			//Alerta o usurio, pois no foi finalizado o processo de registro das anlises de qualidade vinculadas  pesagem
			//
			U_LTALL001("Ateno", "No foram finalizadas as anlises de qualidade vinculadas  est pesagem.", " necessrio que as anlises de qualidade sejam finalizadas antes de executar est funcionalidade.")
		EndIf
	EndIf

Return





/*


`ͻ
Programa  LT019TOK  Autor  Marcelo Joner         Data  29/04/2020 
͹
Desc.     Funo responsvel pela validao geral da interface de     
          Conciliao sob o registro de Pesagem.                      
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019TOK()

	Local lRet		:= .T.
	Local nDesTrp	:= 0
	Local nLitDes	:= 0
	Local cPrdLin	:= GETMV("MV_ZL00005",, "")

//
//Regras de validao quando existe NOTA vinculada h pesagem - no vincula MOV. TRANSPORTADOR
//
	If lTemNf

		//
		//Aplica regras, caso o produto no necessita de controle de LINHA
		//
		If !(ALLTRIM(M->ZM1_PROD) $ cPrdLin)
			Do Case

				//
				//Valida obrigatoriedade na informao do campo LT Nota
				//
			Case M->ZM1_LTNOTA == 0
				U_LTALL001("Ateno", "No foi informado o total de litros presente na nota fiscal vinculada h pesagem.", "Favor informar  quantidade de litros do produto presente na nota fiscal.")
				lRet := .F.

				//
				//Valida obrigatoriedade na informao do campo TP Nota
				//
			Case EMPTY(ALLTRIM(M->ZM1_TPNOTA))
				U_LTALL001("Ateno", "No foi informado o TIPO da nota fiscal vinculada h pesagem.", "Favor informar se a Nota Fsical  de Compra ou Remessa.")
				lRet := .F.

				//
				//Valida obrigatoriedade na composio do valor de SLIDOS KG
				//
			Case M->ZM1_SLKG == 0
				U_LTALL001("Ateno", "No foi composto o valor de slidos sob o peso bruto da carga.", "Favor verificar com o departamento de qualidade  anlise de ST Brix.")
				lRet := .F.

				//
				//Valida obrigatoriedade na composio do valor de SLIDOS LT
				//
			Case M->ZM1_SLLT == 0
				U_LTALL001("Ateno", "No foi composto o valor de slidos sob o total de litros bruto da carga.", "Favor verificar com o departamento de qualidade  anlise de ST Brix.")
				lRet := .F.
			EndCase

			//
			//Valida obrigatoriedade na informao do campo LT Nota
			//
		ElseIf M->ZM1_LTNOTA == 0
			U_LTALL001("Ateno", "No foi informado o total de litros presente na nota fiscal vinculada h pesagem.", "Favor informar  quantidade de litros do produto presente na nota fiscal.")
			lRet := .F.
		EndIf

	Else

		//
		//Regras de validao quando no existe NOTA vinculada h pesagem - vincula MOV. TRANSPORTADOR
		//

		//
		//No permite prosseguir caso  quantidade LT. BRUTO seja diferente de LT VAZAO
		//
		If (M->ZM1_LTVAZ != M->ZM1_LTBRT) .AND. M->ZM1_LTVAZ > 0
			U_LTALL001("Ateno", "O total de litros do LT Movimento  diferente do total de Litros Plataforma.", "Favor verificar os movimentos de transportador vinculados  pesagem.")
			lRet := .F.
		Else
			//
			//Valida que os MOV. TRANSPORTADOR vinculados  pesagem no tenham sido utilizados em outras pesagems
			//
			nRecTRP := (cAliasTRP)->(RECNO())
			dbSelectArea(cAliasTRP)
			(cAliasTRP)->(dbGoTop())
			While (cAliasTRP)->(!EOF())
				dbSelectArea("ZL7")
				ZL7->(dbSetOrder(1))
				ZL7->(dbGoTop())
				If ZL7->(dbSeek(xFilial("ZL7") + (cAliasTRP)->ZL7_COD))
					If !EMPTY(ZL7->ZL7_NUMPES) .AND. ZL7->ZL7_NUMPES != ZM1->ZM1_NUM
						U_LTALL001("Ateno", "O Mov. Transportador (" + ALLTRIM(ZL7->ZL7_COD) + ") est vinculado h outra pesagem (" + ALLTRIM(ZL7->ZL7_NUMPES) + ").", " necessrio que seja vinculado  pesagem, apenas Mov. Transportador que no possuam vinculo h nenhuma outra pesagem.")
						lRet := .F.
						exit
					EndIf
				EndIf

				//
				//Atualiza variveis com valor total de LT Desconto e LT Descarte distribudos nos Mov. Transportador vinculados  Pesagem
				//
				nDesTrp += (cAliasTRP)->ZL7_QTDANT
				nLitDes += (cAliasTRP)->ZL7_QTDDES
				(cAliasTRP)->(dbSkip())
			End

			//
			//Valida se o LT DESCONTO TRANSPORTADOR DISTRIBUDO  igual ao LT DESCONTO TOTAL
			//
			If lRet .AND. nDesTrp != M->ZM1_DESTRP
				U_LTALL001("Ateno", "A quantidade de LT Desconto (" + ALLTRIM(TRANSFORM(nDesTrp, PESQPICT("ZM1", "ZM1_DESTRP"))) + ") atribuda em Mov. Transportador,  inferior  quantidade LT Desconto total (" + ALLTRIM(TRANSFORM(M->ZM1_DESTRP, PESQPICT("ZM1", "ZM1_DESTRP"))) + ").", " necessrio que o total de LT Desconto esteja completamente vinculado  Mov. Transportador da Pesagem.")
				lRet := .F.
			EndIf

			//
			//Valida se o LT DESCARTE DISTRIBUDO  igual ao LT DESCARTE TOTAL
			//
			If lRet .AND. nLitDes != M->ZM1_LTDESC
				U_LTALL001("Ateno", "A quantidade de LT Descarte (" + ALLTRIM(TRANSFORM(nLitDes, PESQPICT("ZM1", "ZM1_LTDESC"))) + ") atribuda em Mov. Transportador,  inferior  quantidade LT Descarte total (" + ALLTRIM(TRANSFORM(M->ZM1_LTDESC, PESQPICT("ZM1", "ZM1_LTDESC"))) + ").", " necessrio que o total de LT Descarte esteja completamente vinculado  Mov. Transportador da Pesagem.")
				lRet := .F.
			EndIf

			//
			//Restaura posicionamento original do grid de Mov. Transportador
			//
			(cAliasTRP)->(dbGoTo(nRecTRP))
		EndIf
	EndIf

Return lRet





/*


`ͻ
Programa  LT019ADD  Autor  Marcelo Joner         Data  27/04/2020 
͹
Desc.     Funo responsvel pela disponibilizao dos recursos para a
          incluso de MOV. TRANSPORTADOR no grid de Coletas.          
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019ADD()

	Local nI			:= 0
	Local nOpcao		:= 2
	Local lRet			:= .T.
	Local lShare		:= .T.
	Local lReadOnly		:= .F.
	Local cCadOld		:= cCadastro
	Local aArea			:= GetArea()
	Local aSize			:= {}
	Local aObjects		:= {}
	Local aInfo			:= {}
	Local aPosObj		:= {}
//Local aDetQld		:= {}
	Local aVwZL7  		:= {{"ZL7_COD"		, "", U_LTALLXSX3("ZL7_COD")[1]		, U_LTALLXSX3("ZL7_COD")[6]		},;
		{"ZL7_DATA"		, "", U_LTALLXSX3("ZL7_DATA")[1]	, U_LTALLXSX3("ZL7_DATA")[6]	},;
		{"ZL7_HORA"		, "", U_LTALLXSX3("ZL7_HORA")[1]	, U_LTALLXSX3("ZL7_HORA")[6]	},;
		{"ZL7_LINHA"	, "", U_LTALLXSX3("ZL7_LINHA")[1]	, U_LTALLXSX3("ZL7_LINHA")[6]	},;
		{"ZL7_NOMLIN"	, "", U_LTALLXSX3("ZL7_NOMLIN")[1]	, U_LTALLXSX3("ZL7_NOMLIN")[6]	},;
		{"ZL7_QTDTRP"	, "", U_LTALLXSX3("ZL7_QTDTRP")[1]	, U_LTALLXSX3("ZL7_QTDTRP")[6]	},;
		{"ZL7_QTDSOB"	, "", U_LTALLXSX3("ZL7_QTDSOB")[1]	, U_LTALLXSX3("ZL7_QTDSOB")[6]	},;
		{"ZL7_QTDFAL"	, "", U_LTALLXSX3("ZL7_QTDFAL")[1]	, U_LTALLXSX3("ZL7_QTDFAL")[6]	}}

	Local aStruct		:= ZL7->(dbStruct())

	Private lInverte	:= .F.
	Private cMarca		:= GetMark()
	Private cAliasZL7	:= GetNextAlias()

	cCadastro := "Movimentos Transportador - Selecionar"

//
//Executa consulta SQL de busca dos MOV. TRANSPORTADOR
//
	cQuery := "SELECT ZL7.*												" + CRLF
	cQuery += "FROM " + RetSQLName("ZL7") + " ZL7						" + CRLF
	cQuery += "WHERE ZL7.ZL7_FILIAL  = '" + xFilial("ZL7")      + "'	" + CRLF
	cQuery += "  AND ZL7.ZL7_DATA    = '" + DTOS(ZM1->ZM1_DATA) + "'	" + CRLF
	cQuery += "  AND ZL7.ZL7_PLACA    = '" + ZM1->ZM1_PLACA + "'	" + CRLF
	cQuery += "  AND ZL7.ZL7_NUMPES IN (' ', '" + ZM1->ZM1_NUM + "')	" + CRLF
	cQuery += "  AND ZL7.D_E_L_E_T_ <> '*'								" + CRLF

	cQuery += "ORDER BY ZL7_FILIAL, ZL7_DATA, ZL7_HORA, ZL7_COD			" + CRLF

	cArqTrab  := CriaTrab(aStruct, .T. )

	If Select(cAliasZL7) > 0
		(cAliasZL7)->(dbCloseArea())
	EndIf

	cQuery := ChangeQuery(cQuery)

	TCQUERY cQuery NEW ALIAS cAliasZL7

	Copy TO &cArqTrab
	dBCloseArea()
	dBUseArea( .T.,, cArqTrab, cAliasZL7, lShare, lReadOnly )
	(cAliasZL7)->(dbGoTop())

//
//Remove os MOV. TRANSPORTADOR que esto vinculados  pesagem
//
	While (cAliasZL7)->(!EOF())
		dbSelectArea(cAliasTRP)
		(cAliasTRP)->(dbGoTop())
		While (cAliasTRP)->(!EOF())
			If (cAliasTRP)->ZL7_COD == (cAliasZL7)->ZL7_COD
				RECLOCK(cAliasZL7, .F.)
				(cAliasZL7)->(DBDELETE())
				(cAliasZL7)->(MSUNLOCK())

				exit
			EndIf
			(cAliasTRP)->(dbSkip())
		End
		(cAliasZL7)->(dbSkip())
	End
	(cAliasZL7)->(dbGoTop())

//
//Calcula dimenso da interface\componentes
//
	aSize := MsAdvSize()
	aSize[5] -= 100
	aSize[7] := 200

//
// Montagem dos parmetros para criao da tela de exibio
//
	AAdd(aObjects, {100, 100, .T., .F.})
	aInfo := {aSize[1], aSize[2], aSize[3] / 2, aSize[4] / 2, 2, 2}
	aPosObj := MsObjSize(aInfo, aObjects, .T.)

//
//Monta dialog e demais componentes
//
	oDlgCons := MSDialog():New(aSize[7],0,aSize[6],(aSize[5]/1.5), cCadastro,,,.F.,,,,,,.T.,,,.T. )
	oDlgCons:bInit := {|| ENCHOICEBAR(oDlgCons, {|| (nOpcao := 1, oDlgCons:End())}, {|| (nOpcao := 2, oDlgCons:End())}, .F., {})}
	oBrwCons := MsSelect():New(cAliasZL7,"","",aVwZL7,@lInverte,@cMarca,{aPosObj[1,1],aPosObj[1,2],(oDlgCons:nClientHeight/2)-11, (oDlgCons:nClientWidth/2)-5},,,oDlgCons)
	oBrwCons:oBrowse:bLDblClick := {|| (nOpcao := 1, oDlgCons:End())}
	oDlgCons:Activate(,,,.T.)

//
//Confirmando  interface, adiciona o MOV. TRANSPORTADOR  pesagem
//
	If nOpcao == 1
		If !EMPTY((cAliasZL7)->ZL7_COD)

			//
			//Posiciona no cadastro do Mov. Transportador
			//
			dbSelectArea("ZL7")
			ZL7->(dbSetOrder(1))
			ZL7->(dbGoTop())
			If ZL7->(dbSeek(xFilial("ZL7") + (cAliasZL7)->ZL7_COD))

				//
				//Verifica se  possvel utilizar o Mov. Transportador selecionado
				//
				If U_LTMOV2VD()

					//
					//Vincula os dados do Mov. Transportador  tabela temporria
					//
					dbSelectArea(cAliasTRP)
					RECLOCK(cAliasTRP, .T.)
					For nI := 1 To FCount()
						FieldPut(nI, (cAliasZL7)->&(FieldName(nI)))
					Next nI
					(cAliasTRP)->(MSUNLOCK())
				EndIf

				oBrwTrp:oBrowse:Refresh()
			EndIf
		EndIf
	EndIf

//
//Fecha alias temporrio utilizado na consulta
//
	If Select(cAliasZL7) > 0
		(cAliasZL7)->(dbCloseArea())
	EndIf

//
//Executa funo de atualizao dos totais
//
	LT019TRPRF()

	RestArea(aArea)
	cCadastro := cCadOld

Return lRet





/*


`ͻ
Programa  LT019DEL  Autor  Marcelo Joner         Data  28/04/2020 
͹
Desc.     Funo responsvel pela disponibilizao dos recursos para ັ
          excluso de MOV. TRANSPORTADOR no grid de Coletas.          
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019DEL()

//
//Realiza excluso, desde que esteja posicionado em registro vlido no grid
//
	dbSelectArea(cAliasTRP)
	If !EMPTY((cAliasTRP)->ZL7_COD)
		RECLOCK(cAliasTRP, .F.)
		(cAliasTRP)->(DBDELETE())
		(cAliasTRP)->(MSUNLOCK())

		oBrwTrp:oBrowse:Refresh()
	EndIf

//
//Executa funo de atualizao dos totais
//
	LT019TRPRF()

Return





/*


`ͻ
Programa  LT019DET  Autor  Marcelo Joner         Data  29/04/2020 
͹
Desc.     Funo responsvel pela disponibilizao dos recursos para ັ
          visualizao dos detalhes do MOV. TRANSPORTADOR posicionado 
          no grid de Coletas.                                         
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019DET(cOpcao)

	Local aArea		:= GetArea()
	Local cCadOld	:= cCadastro
	Local cCondicao	:= ""
	Local lMovTrans	:= !EMPTY((cAliasTRP)->ZL7_COD)

	Default cOpcao	:= ""

	Do Case

		//
		//Executa regras quando trata-se de manipulao MOV. PRODUTOR
		//
	Case cOpcao == "P"

		//
		//Executa rotina de MOV. PRODUTOR
		//
		U_LTMOV001()




		//
		//Executa regras quando trata-se de manipulao MOV. TRANSPORTADOR
		//
	Case cOpcao == "T"

		//
		//Filtra a ZL7 apenas com o MOV. TRANSPORTADOR vinculado
		//
		If lMovTrans
			cCondicao := "ZL7_FILIAL == '" + xFilial("ZL7") + "' .AND. ZL7_COD == '" + (cAliasTRP)->ZL7_COD + "'"
			dbSelectArea("ZL7")
			ZL7->(dbSetOrder(1))
			ZL7->(dbGoTop())
			ZL7->(dbSetFilter({||&(cCondicao)}, cCondicao))
			ZL7->(dbGoTop())
		EndIf

		//
		//Executa rotina de MOV. TRANSPORTADOR
		//
		U_LTMOV002()

		//
		//Remove o filtro da tabela ZL7 aps sair da rotina de MOV. TRANSPORTADOR
		//
		ZL7->(dbClearFilter())

	EndCase

	RestArea(aArea)
	cCadastro := cCadOld

Return





/*


`ͻ
Programa  LT019TRPRF  Autor  Marcelo Joner       Data  28/04/2020 
͹
Desc.     Funo responsvel pela realizao do recalculo dos totais  
          de acordo com os MOV. TRANSPORTADOR vinculados  pesagem.   
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019TRPRF()

	Local nQtdLt	:= 0
	Local nQtdTrp	:= 0
	Local nQtdVaz	:= 0
	Local nRecTRP	:= 0

//
//Obtm os totais com base nos MOV. TRANSPORTADOR vinculados  pesagem
//
	dbSelectArea(cAliasTRP)
	(cAliasTRP)->(dbGoTop())
	While (cAliasTRP)->(!EOF())
		nQtdLt  += (cAliasTRP)->ZL7_QTDTRP

		//
		//Regras quando  ajuste automtico da diferena
		//
		If !ISINCALLSTACK("LT019TRPAJ")
			RECLOCK(cAliasTRP, .F.)
			(cAliasTRP)->ZL7_QTDFAL := 0
			(cAliasTRP)->ZL7_QTDSOB := 0
			(cAliasTRP)->ZL7_QTDDES := 0
			(cAliasTRP)->ZL7_QTDVAZ := (cAliasTRP)->ZL7_QTDTRP
			(cAliasTRP)->(MSUNLOCK())

			//
			//Identifica o MOV. TRANSPORTADOR de maior quantidade para depois sugerir ajuste de diferena
			//
			If (cAliasTRP)->ZL7_QTDTRP > nQtdTrp
				nQtdTrp := (cAliasTRP)->ZL7_QTDTRP
				nRecTRP := (cAliasTRP)->(RECNO())
			EndIf
		EndIf

		(cAliasTRP)->(dbSkip())
	End

//
//Atualiza campos na sesso de CONVERSO
//
	M->ZM1_LTMOV := ROUND((nQtdLt), 0)
	M->ZM1_LTDIF := ROUND(((M->ZM1_LTBRT + M->ZM1_LTDESC) - M->ZM1_LTMOV), 0)

//
//Havendo diferena entre LT Bruto e LT Coleta, sugere ajuste no MOV. TRANSPORTADOR de maior volume
//
	dbSelectArea(cAliasTRP)
	(cAliasTRP)->(dbGoTop())
	While (cAliasTRP)->(!EOF())

		//
		//Regras quando  ajuste automtico da diferena
		//
		If !ISINCALLSTACK("LT019TRPAJ")
			RECLOCK(cAliasTRP, .F.)
			If (cAliasTRP)->(RECNO()) == nRecTRP
				If M->ZM1_LTDIF >= 0
					(cAliasTRP)->ZL7_QTDSOB := M->ZM1_LTDIF
					(cAliasTRP)->ZL7_QTDDES := M->ZM1_LTDESC
					(cAliasTRP)->ZL7_QTDVAZ := ROUND(((cAliasTRP)->ZL7_QTDTRP + (cAliasTRP)->ZL7_QTDSOB), 0)
				Else
					(cAliasTRP)->ZL7_QTDFAL := ABS(M->ZM1_LTDIF)
					(cAliasTRP)->ZL7_QTDDES := M->ZM1_LTDESC
					(cAliasTRP)->ZL7_QTDVAZ := ROUND(((cAliasTRP)->ZL7_QTDTRP - (cAliasTRP)->ZL7_QTDFAL), 0)
				EndIf
			Else
				(cAliasTRP)->ZL7_QTDVAZ := (cAliasTRP)->ZL7_QTDTRP
			EndIf
			(cAliasTRP)->(MSUNLOCK())
		EndIf

		nQtdVaz += ROUND(((cAliasTRP)->ZL7_QTDVAZ - (cAliasTRP)->ZL7_QTDDES), 0)
		(cAliasTRP)->(dbSkip())
	End

//
//Atualiza total de vazo
//
	M->ZM1_LTVAZ  := nQtdVaz
//M->ZM1_SITCON := "F"

//
//Atualiza os componentes da interface
//
	(cAliasTRP)->(dbGoTop())
	oGetCon:Refresh()

Return





/*


`ͻ
Programa  LT019TRPAJ  Autor  Marcelo Joner       Data  28/04/2020 
͹
Desc.     Funo responsvel pela apresentao de interface secundria
          referente h ajuste na diferena junto ao MOV. TRANSPORTADOR
          posicionado no grid. Executado atravs de duplo-clique.     
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019TRPAJ()

	Local nOpc		:= 2
	Local nQuant	:= ABS(M->ZM1_LTDIF)
//Local nTotal	:= ABS(M->ZM1_LTDIF)
	Local nQtdDes	:= M->ZM1_DESTRP
//Local nTotDes	:= M->ZM1_DESTRP
	Local nQtdDesc	:= M->ZM1_LTDESC
//Local nTotDesc	:= M->ZM1_LTDESC
	Local lEdtAju	:= (cAliasTRP)->(RECCOUNT()) > 1 .AND. ABS(M->ZM1_LTDIF) > 0
	Local lEdtDes	:= M->ZM1_DESTRP > 0
	Local lEdtDesc	:= (cAliasTRP)->(RECCOUNT()) > 1 .AND. ABS(M->ZM1_LTDESC) > 0
	Local cCadOld	:= cCadastro
//Local bAlert	:= {|| U_LTALL001("Ateno", "A quantidade de litros informado para o ajuste  superior  diferena total da carga.", "A quantidade de litros de ajuste deve ser menor ou igual  diferena total."), .F.}
//Local bAltDes	:= {|| U_LTALL001("Ateno", "A quantidade de litros informado para o desconto  superior ao desconto total da carga.", "A quantidade de litros de desconto deve ser menor ou igual ao desconto total."), .F.}
//Local bAltDesc	:= {|| U_LTALL001("Ateno", "A quantidade de litros informado para o descarte  superior ao descarte total da carga.", "A quantidade de litros de descarte deve ser menor ou igual ao descarte total."), .F.}

	Private nRecAJU	:= (cAliasTRP)->(RECNO())

	cCadastro := "Movimento Transportador - Ajuste"

/*ٱ
 Definicao do Dialog e todos os seus componentes.                        
ٱ*/
oDlgSel := MSDialog():New(091,232,185,585, cCadastro,,,.F.,,,,,,.T.,,,.T. )
	oSay1  := TSay():New(007,004,{|| "LT Ajuste"},oDlgSel,,,.F.,.F.,.F.,.T.,CLR_HBLUE,CLR_WHITE,048,008)
	@006,056 MSGET oGet1 VAR nQuant   PICTURE PesqPict("ZM1", "ZM1_LTDIF") OF oDlgSel WHEN lEdtAju PIXEL SIZE 70,008 HASBUTTON
	
	oSay2  := TSay():New(020,004,{|| "LT Desconto"},oDlgSel,,,.F.,.F.,.F.,.T.,CLR_HBLUE,CLR_WHITE,048,008)
	@019,056 MSGET oGet2 VAR nQtdDes  PICTURE PesqPict("ZM1", "ZM1_LTDIF") OF oDlgSel WHEN lEdtDes PIXEL SIZE 70,008 HASBUTTON
	
	oSay3  := TSay():New(033,004,{|| "LT Descarte"},oDlgSel,,,.F.,.F.,.F.,.T.,CLR_HBLUE,CLR_WHITE,048,008)
	@032,056 MSGET oGet3 VAR nQtdDesc PICTURE PesqPict("ZM1", "ZM1_LTDIF") OF oDlgSel WHEN lEdtDesc PIXEL SIZE 70,008 HASBUTTON
	
	oSBtn1 := SButton():New(018,143,1,{|| nOpc := 1, oDlgSel:End()},oDlgSel,,"",)
oDlgSel:Activate(,,,.T.)

//
//Confirmando  interface, proceder com os ajustes
//
If nOpc == 1
	RECLOCK(cAliasTRP, .F.)
		If M->ZM1_LTDIF > 0
			(cAliasTRP)->ZL7_QTDFAL := 0
			(cAliasTRP)->ZL7_QTDSOB := nQuant
			(cAliasTRP)->ZL7_QTDVAZ := ROUND(((cAliasTRP)->ZL7_QTDTRP + (cAliasTRP)->ZL7_QTDSOB), 2)
		Else
			(cAliasTRP)->ZL7_QTDSOB := 0
			(cAliasTRP)->ZL7_QTDFAL := nQuant
			(cAliasTRP)->ZL7_QTDVAZ := ROUND(((cAliasTRP)->ZL7_QTDTRP - (cAliasTRP)->ZL7_QTDFAL), 2)
		EndIf
		
		(cAliasTRP)->ZL7_QTDANT := nQtdDes
		(cAliasTRP)->ZL7_QTDDES := nQtdDesc
	(cAliasTRP)->(MSUNLOCK())
	
	//
	//Executa funo para atualizao do grid e totais da tela
	//
	LT019TRPRF()
EndIf

cCadastro := cCadOld
(cAliasTRP)->(dbGoTo(nRecAJU))

Return





/*


`ͻ
Programa  LT019CLCSL Autor  Marcelo Joner        Data  29/04/2020 
͹
Desc.     Funo responsvel pelo clculo de slidos.                 
                                                                      
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019CLCSL()

	Local nCount	:= 0
	Local nValBrix	:= 0
	Local _cBrix	:= AllTrim(GetMv("MX_LT009BR"))

	If Empty(_cBrix)
		MsgAlert("No foi definido no parmetro o cdigo do Brix no cadastro de Anlises. Verificar o parmetro MX_LT009BR")
		Return {0, 0, 0}
	EndIf

//
//Obtm o valor mdio do ST BRIX com base nas anlises dos tanques da pesagem
//
	dbSelectArea("ZM3")
	ZM3->(dbSetOrder(1))
	ZM3->(dbGoTop())
	If ZM3->(dbSeek(xFilial("ZM3") + ZM1->ZM1_NUM))
		While ZM3->(!EOF()) .AND. ZM3->ZM3_FILIAL == xFilial("ZM3") .AND. ZM3->ZM3_NUM == ZM1->ZM1_NUM
			If ZM3->ZM3_STATUS == "A"
				nCount++
				nValBrix += ZM3->ZM3_QLD022
			EndIf

			ZM3->(dbSkip())
		End

		nValBrix := ROUND((nValBrix / nCount), 1)
	Else
		dbSelectArea('ZM5')
		ZM5->(dbSetOrder(1))
		ZM5->(dbGoTop())
		If ZM5->(dbSeek(xFilial('ZM5')+ZM1->ZM1_NUM))
			While ZM5->(!Eof()) .And. ZM5->ZM5_FILIAL == xFilial("ZM5") .AND. ZM5->ZM5_NUM == ZM1->ZM1_NUM
				If ZM5->ZM5_CARACT == _cBrix .AND. ZM5->ZM5_STATUS $ 'A/P'
					nCount++
					nValBrix += ZM5->ZM5_VALOR
				EndIf
				ZM5->(DbSkip())
			EndDo
			nValBrix := ROUND((nValBrix / nCount), 1)
		EndIf
	EndIf

//
//A partir do ST BRIX obtido, clcula os valores de slidos por KG e LT bruto
//
	nSlKG := ROUND(((M->ZM1_KGBRT) * (nValBrix / 100)), 2)
	nSlLT := ROUND((M->ZM1_LTBRT * (nValBrix / 100)), 2)

Return {nValBrix, nSlKG, nSlLT}





/*


`ͻ
Programa  LT019LNF  Autor  Marcelo Joner         Data  29/04/2020 
͹
Desc.     Funo vinculada  edio do campo ZM1_LTNOTA. Responsvel  
          pela validao do valor informado e tambm pela atualizao 
          do campo ZM1_LTDIF.                                         
͹
Uso        Laticinio                                                  
ͼ


*/
User Function LT019LNF()

	Local lRet := .F.

//
//Calcula diferena caso  quantidade LT Nota seja positiva
//
	If POSITIVO(M->ZM1_LTNOTA)
		lRet := .T.
		M->ZM1_LTDIF  := ROUND((M->ZM1_LTBRT - M->ZM1_LTNOTA), 2)
		If M->ZM1_LTNOTA > 0 .AND. M->ZM1_PRCSOL > 0
			M->ZM1_SITCON := "F"
		EndIf
	EndIf

Return





/*


`ͻ
Programa  LT019FT01 Autor  Marcelo Joner         Data  29/04/2020 
͹
Desc.     Funo responsvel pela execuo das regras referentes     
          composio do fator de converso considerado quando trata-se
          de SORO IN NATURA. Vinculado ao cadastro de Frmulas.       
͹
Uso        Laticinio                                                  
ͼ


*/
User Function LT019FT01()

	Local nFator	:= 0
	Local nCount	:= 0
	Local nValDen	:= 0
	Local _cDensid  := AllTrim(GetMv("MX_LT009DE"))

//
//Calcula o fator com base nas anlises de densidade
//
	dbSelectArea("ZM3")
	ZM3->(dbSetOrder(1))
	ZM3->(dbGoTop())
	If ZM3->(dbSeek(xFilial("ZM3") + ZM1->ZM1_NUM))
		While ZM3->(!EOF()) .AND. ZM3->ZM3_FILIAL == xFilial("ZM3") .AND. ZM3->ZM3_NUM == ZM1->ZM1_NUM
			If ZM3->ZM3_STATUS == "A"
				nCount++
				nValDen += ZM3->ZM3_QLD008
			EndIf

			ZM3->(dbSkip())
		End

		//
		//Calcula  densidade mdia da carga
		//
		nFator := ROUND((nValDen / nCount), 0)

		//
		//Calcula o total de litros  partir do peso bruto da carga
		//
		nFator := ROUND(((ZM1->ZM1_KGBRT / nFator) * 1000), TAMSX3("ZM1_LTBRT")[2])

		//
		//Calcula o fator de converso por KG x LT
		//
		nFator := ROUND((nFator / ZM1->ZM1_KGBRT), TAMSX3("ZM1_FATCON")[2])
	Else
		dbSelectArea('ZM5')
		ZM5->(dbSetOrder(1))
		ZM5->(dbGoTop())
		If ZM5->(dbSeek(xFilial('ZM5')+ZM1->ZM1_NUM))
			While ZM5->(!Eof()) .And. ZM5->ZM5_FILIAL+ZM5->ZM5_NUM == xFilial('ZM5')+ZM1->ZM1_NUM
				If ZM5->ZM5_CARACT == _cDensid .AND. ZM5->ZM5_STATUS $ 'A/P'
					nCount++
					nValDen += ZM5->ZM5_VALOR
				EndIf
				ZM5->(DbSkip())
			EndDo

			//
			//Calcula  densidade mdia da carga
			//
			nFator := ROUND((nValDen / nCount), 0)

			//
			//Calcula o total de litros  partir do peso bruto da carga
			//
			nFator := ROUND(((ZM1->ZM1_KGBRT / nFator) * 1000), TAMSX3("ZM1_LTBRT")[2])

			//
			//Calcula o fator de converso por KG x LT
			//
			nFator := ROUND((nFator / ZM1->ZM1_KGBRT), TAMSX3("ZM1_FATCON")[2])

		EndIf
	EndIf

Return nFator





/*


`ͻ
Programa  LT019INI  Autor  Marcelo Joner         Data  05/05/2020 
͹
Desc.     Funo responsvel pela execuo de regras na inicializao 
          da interface da funcionalidade de Conciliao.              
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019INI(lEdtCon)

//
//Caso usurio possui permisso para utilizar  funcionalidade, seta foco no grid de Mov. Transportador
//
	If lEdtCon
		If EMPTY(ZM1->ZM1_NFCOM)
			SETFOCUS(oBrwTrp:oBrowse:hWnd)
		Else
			SETFOCUS(oGetCon:hWnd)
		EndIf
	Else
		//
		//Caso o usurio no possui permisso, apresenta mensagem alertando ao mesmo
		//
		U_LTALL001("Ateno", "O seu usurio no possui permisso para utilizar est funcionalidade.", "Somente ser possvel visualizar as informaes referentes  conciliao desta pesagem.")
	EndIf

Return





/*


`ͻ
Programa  LT019GRV  Autor  Marcelo Joner         Data  30/04/2020 
͹
Desc.     Funo responsvel pela gravao das informaes referentes 
           funcionalidade de Conciliao.                            
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019GRV()

	Local aArea			:= GetArea()
	Local aMOV002		:= {}
	Local nI			:= 0
	Private lMsErroAuto	:= .F.

	BEGIN TRANSACTION

		If M->ZM1_SITCON != ZM1->ZM1_SITCON

			If  ( ALLTRIM(M->ZM1_PROD) $ SuperGetMv("LTS_PRDDIF",,"") .AND. M->ZM1_PRCSOL <= 0 .AND. M->ZM1_SITCON == 'F' .and. ZM1_TPNOTA == '1' )
			
				U_GLALL001("Ateno", "No foi possvel concluir a conciliao, preo do slido no informado", "Favor verificar verificar com o setor de captao.")
				ZM1->ZM1_SITCON := "P"
				M->ZM1_SITCON := "P"
			
			ElseIf ALLTRIM(M->ZM1_PROD) $ SuperGetMv("LTS_PRDDIF",,"")

				If M->ZM1_SITCON != 'F' .and. ZM1->ZM1_SITCON == "F"
					U_LSEST07()
				ElseIf M->ZM1_SITCON == 'F' .and. ZM1->ZM1_SITCON == "P" .and. M->ZM1_PRCSOL > 0 .and. !EMPTY(POSICIONE("SD1",1,XFILIAL("SD1")+M->ZM1_NFCOM+M->ZM1_SRCOM+M->ZM1_CLIFOR+M->ZM1_LOJA,"D1_DOC"))
					U_LSEST08()
				EndIf
			EndIf
		EndIf
		
		If M->ZM1_SITCON != 'F' .and. ZM1->ZM1_SITCON == "F"
			If ApMsgNoYes("Deseja reabrir os lanamentos da Qualidade?", "Ateno")
				ZM1->ZM1_SITQLD := "P"
				M->ZM1_SITQLD := "P"
			EndIf
		EndIf

		//
		//Realiza  gravao dos dados na tabela de Pesagem
		//
		dbSelectArea("ZM1")
		RECLOCK("ZM1", .F.)

		For nI := 1 To FCount()
			If FieldName(nI) == "ZM1_FILIAL"
				FieldPut(nI, xFilial("ZM1"))
			Else
				FieldPut(nI, M->&(FieldName(nI)))
			EndIf
		Next nI

		ZM1->ZM1_USRCON := __cUserId
		ZM1->ZM1_NOMCON := cUserName
		ZM1->ZM1_DTCON  := dDataBase
		ZM1->ZM1_HRCON  := SUBSTR(GetRmtTime(), 1, 5)
		ZM1->(MSUNLOCK())


		//
		//Remove o vinculo da Pesagem aos Mov. Transportador vinculados anteriormente
		//
		While .T.
			dbSelectArea("ZL7")
			ZL7->(dbSetOrder(4))
			ZL7->(dbGoTop())
			If ZL7->(dbSeek(xFilial("ZL7") + ZM1->ZM1_NUM))
				While ZL7->(!EOF()) .AND. ZL7->ZL7_FILIAL == xFilial("ZL7") .AND. ZL7->ZL7_NUMPES == ZM1->ZM1_NUM
					RECLOCK("ZL7", .F.)
					ZL7->ZL7_NUMPES := ""
					ZL7->(MSUNLOCK())

					ZL7->(dbSkip())
				End
			Else
				exit
			EndIf
		End

		//
		//Realiza atualizao dos Mov. Transportador vinculados h pesagem atualmente
		//
		dbSelectArea(cAliasTRP)
		(cAliasTRP)->(dbGoTop())
		While (cAliasTRP)->(!EOF())

			//
			//Prepara array para atualizao do Mov. Transportador
			//
			aMOV002 := {}
			AADD(aMOV002, {'ZL7_FILIAL', xFilial("ZL7")				, Nil})
			AADD(aMOV002, {'ZL7_COD'   , (cAliasTRP)->ZL7_COD		, Nil})
			AADD(aMOV002, {'ZL7_QTDVAZ', (cAliasTRP)->ZL7_QTDVAZ	, Nil})
			AADD(aMOV002, {'ZL7_QTDANT', (cAliasTRP)->ZL7_QTDANT	, Nil})
			AADD(aMOV002, {'ZL7_QTDTRP', (cAliasTRP)->ZL7_QTDTRP	, Nil})
			AADD(aMOV002, {'ZL7_QTDCRI', (cAliasTRP)->ZL7_QTDCRI	, Nil})
			AADD(aMOV002, {'ZL7_QTDSOB', (cAliasTRP)->ZL7_QTDSOB	, Nil})
			AADD(aMOV002, {'ZL7_QTDFAL', (cAliasTRP)->ZL7_QTDFAL	, Nil})
			AADD(aMOV002, {'ZL7_QTDANT', (cAliasTRP)->ZL7_QTDANT	, Nil})
			AADD(aMOV002, {'ZL7_QTDDES', (cAliasTRP)->ZL7_QTDDES	, Nil})
			AADD(aMOV002, {'ZL7_NUMPES', ZM1->ZM1_NUM				, Nil})

			//
			//Executa rotina de alterao do Mov. Transportador
			//
			MSExecAuto({|x,y| U_LTMOV002(x,y)}, aMOV002, 4)

			//
			//Verifica se ocorreu erro na atualizao do Mov. Transportador
			//
			If lMsErroAuto
				DISARMTRANSACTION()
				U_GLALL001("Ateno", "Ocorreram erros na atualizao do Mov. Transportador (" + ALLTRIM(ZL7->ZL7_COD) + ") vinculado  pesagem.", "Favor verificar o log apresentado  seguir.")
				MOSTRAERRO()
				Return
			EndIf

			(cAliasTRP)->(dbSkip())
		End

	END TRANSACTION

	RestArea(aArea)

Return

//============================================================================\
/*/{Protheus.doc}LTMOV009C 
  ==============================================================================
	@description
	Recalcula Conciliao

	@author Alexandre Longhinotti <ti@tresbarras.ind.br>
	@version 1.0
	@since 10/11/2020

/*/  
//============================================================================\
Static Function LT019RECC(lTemNf, aDetSL)
	//
	//Executa funo de clculo dos solidos
	//
	If M->ZM1_SITCON != ZM1->ZM1_SITCON .OR. ( M->ZM1_SITCON == 'P' .AND. ZM1->ZM1_SITCON == 'P' )
		If lTemNf
			If M->ZM1_SITCON != 'F'
				aDetSL := LT019CLCSL()
				M->ZM1_QLD022 := aDetSL[1]
				M->ZM1_SLKG   := aDetSL[2]
				M->ZM1_SLLT   := aDetSL[3]
				M->ZM1_LTDIF  := ROUND(((M->ZM1_LTBRT + M->ZM1_LTDESC) - M->ZM1_LTNOTA), 0)
				M->ZM1_PRCSOL := U_LTPRCSOL()
				//MsgAlert("Recalculo efetuado com Sucesso!")
			else
				MsgAlert("No foi possvel efetuar o recalculo. Verificar o Status da conciliao!")
			EndIf
		Else
			M->ZM1_LTDIF  := ROUND(((M->ZM1_LTBRT + M->ZM1_LTDESC) - M->ZM1_LTMOV), 0)
		EndIf
	EndIf
Return
// FIM da Funcao LTMOV009C
//==============================================================================

//============================================================================\
/*/{Protheus.doc}LT019ZERPR 
  ==============================================================================
	@description
	Recalcula Conciliao

	@author Alexandre Longhinotti <ti@tresbarras.ind.br>
	@version 1.0
	@since 10/12/2021

/*/  
//============================================================================\
Static Function LT019ZERPR(lTemNf, aDetSL)

	If M->ZM1_SITCON != ZM1->ZM1_SITCON .OR. ( M->ZM1_SITCON == 'P' .AND. ZM1->ZM1_SITCON == 'P' )
		If lTemNf
			If M->ZM1_SITCON != 'F'
				M->ZM1_PRCSOL := 0
				MsgAlert("Preo zerado com Sucesso!")
			else
				MsgAlert("No foi possvel zerar o preo. Verificar o Status da conciliao!")
			EndIf
		EndIf
	EndIf
Return
// FIM da Funcao LT019ZERPR
//==============================================================================






/*


`ͻ
Programa  LT019LOG  Autor  Marcelo Joner         Data  05/05/2020 
͹
Desc.     Funo responsvel pela apresentao das informaes de log 
          de execuo na realizao do processo de Conciliao.       
͹
Uso        Laticinio                                                  
ͼ


*/
Static Function LT019LOG()

	Local aArea			:= GetArea()
	Local aCpoCad 		:= {'NOUSER', 'ZM1_USRCON', 'ZM1_NOMCON', 'ZM1_DTCON', 'ZM1_HRCON'}
	Local aAltCad 		:= {''}
	Local aSize			:= {}
	Local aObjects		:= {}
	Local aInfo			:= {}
//Local lRet			:= .T.
	Local lF3			:= .F.
	Local lColumn		:= .F.
	Local lMemoria		:= .T.
	Local lNoFolder		:= .T.
	Local lProperty		:= .F.
	Local cCadOld		:= cCadastro

	Default nOpc		:= 1

	Private aGets[0]
	Private aTela[0][0]

//
//Ajusta o ttulo que ser apresentado no dialog ao usurio
//
	cCadastro := "Pesagem - Log de Conciliao"

//
//Calcula tamanho\posicionamento da interface
//
	aSize := MsAdvSize(.T.)
	AADD(aObjects, {100, 100, .T., .T.})
	aInfo := {aSize[1], aSize[2], aSize[3], aSize[4], 2, 2}
	aPosObj := MsObjSize(aInfo, aObjects, .T.)

//
//Declarao do dialog e demais componentes da interface secundria
//
	oDlgLog := MSDialog():New(089,232,IIF(nOpc == 4, 220, 260),920,cCadastro,,,.F.,,,,,,.T.,,,.T. )
	oDlgLog:bInit := {|| ENCHOICEBAR(oDlgLog, {|| oDlgLog:End()}, {|| oDlgLog:End()}, .F., {})}
	oGetCad := MSMGET():NEW("ZM1",0, nOpc, /*aCRA*/,/*cLetra*/,/*cTexto*/, aCpoCad, {aPosObj[1][1], 001, (oDlgLog:nClientHeight / 2)-15,(oDlgLog:nClientWidth / 2)-5}, aAltCad, 2,/*nColMens*/,/*cMensagem*/,'',oDlgLog, lF3, lMemoria, lColumn,/*caTela*/,lNoFolder,lProperty, /*aField*/, /*aFolder*/, .F., /*lNoMDIStretch*/,/*cTela*/)
	oDlgLog:Activate(,,,.T.)

	cCadastro := cCadOld

	RestArea(aArea)

Return





/*


`ͻ
Programa  LT019LDS  Autor  Marcelo Joner         Data  26/05/2020 
͹
Desc.     Funo vinculada como funo de validao campo ZM1_DESTRP  
          no processo de conciliao de pesagem.                      
͹
Uso        Laticinio                                                  
ͼ


*/
User Function LT019LDS()

	Local lRet		:= .T.

//
//No permite que o LT Desconto seja superior ao LT Vazo
//
	If POSITIVO()
		If M->ZM1_DESTRP > M->ZM1_LTVAZ
			U_LTALL001("Ateno", "A quantidade de LT Desconto informada  invlida.", "A quantidade de LT Desconto deve ser menor ou igual  quantidade LT Movimento.")
			lRet := .F.
		EndIf
	Else
		lRet := .F.
	EndIf

Return lRet
